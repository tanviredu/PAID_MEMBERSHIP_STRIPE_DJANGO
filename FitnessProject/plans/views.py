from django.shortcuts import render,get_object_or_404,redirect,HttpResponse
from django.views import generic
from .forms import CustomerSignupForm
from .models import Customer,FitnessPlan
from django.urls import reverse_lazy
from django.contrib.auth import authenticate,login,logout
from django.contrib.auth.decorators import login_required,user_passes_test
import stripe
stripe.api_key = "<use the private api here>" 


def home(request):
    plans = FitnessPlan.objects 
    return render(request,'plans/home.html',{'plans':plans})
    
def logout_user(request):
    logout(request)
    return redirect('home')
    
def redi(request):
    return redirect('home')
def plan(request,pk):
    plan = get_object_or_404(FitnessPlan,pk=pk)
    ## if the plan he choose if premium
    if plan.premium:
        ## check if the user is authenticated
        ## without authentication and membership cant see the 
        ## premium plan
        if request.user.is_authenticated:
            try:
                if request.user.customer.membership:
                    return render(request,'plans/plan.html',{'plan':plan})
            except Customer.DoesNotExist:
                return redirect('join')
        return redirect('join')
    else:
        return render(request,'plans/plan.html',{'plan':plan})


def red_to_login(request):
    return redirect('login')
        
## you can do it in the function 
class SignUp(generic.CreateView):
    form_class = CustomerSignupForm
    success_url = reverse_lazy('home')
    template_name = 'registration/signup.html'
    
    ## this is a default function
    ## in class based view
    def form_valid(self, form):
        ## passing to the base class
        ## valid variable will be boolean
        valid = super(SignUp,self).form_valid(form)
        username,password = form.cleaned_data.get('username'),form.cleaned_data.get('password1')
        
        ## create the new user
        new_user = authenticate(username=username,password = password)
        ## login the user
        
        ## self.request have to be passed
        login(self.request,new_user)
        return valid 
        
def join(request):
    return render(request,'plans/join.html')
        

@login_required
def checkout(request):
    ## first try to find if the member have already 
    ## membership then send it to the settings page
    try:
        if request.user.customer.membership:
            return redirect('settings')
    except Customer.DoesNotExist:
        pass

    ## make the coupons
    coupons = {'halloween':31,'welcome':10}

    ## if user purchange with the button
    if request.method == "POST":
        ## sript token will be autogenerated
        stripe_customer = stripe.Customer.create(email=request.user.email, source=request.POST['stripeToken'])
        ## default plan is monthly
        ## all the plan api comes from the stript
        # this is monthly (default)
        plan = 'price_1H2FvRGIq20I0NkRtyFjb1zx'
        ## you may wonder when i post it here
        ## it is posted in the hidden field
        ## it take the data from the get req and then 
        ## post it in the form in hidden field
        if request.POST['plan'] == 'yearly':
            plan = 'price_1H2FvRGIq20I0NkR6BffPYJF'
        ## coupon is also posted in hidden field
        ## it take the data from the get req and then 
        ## post it in the form in hidden field
        if request.POST['coupon'] in coupons:
            ## if the  coupon is valid 
            ## means in the dict
            ## then
            ## find it
            c = request.POST['coupon'].lower()
            percentage = coupons[c]
            try:
                ## if there is a coupon then tel the stripe that
                ## there is a coupon
                coupon = stripe.Coupon.create(duration='once',id=c,percent_off=percentage)
            except:
                ##otherwise move on
                pass

            ## now create a subscription
            subscription = stripe.Subscription.create(customer=stripe_customer.id,items=[{'plan':plan}],coupon=c)
        
        else:
            ### if user dont provide a coupon then
            ### create subscription without the coupon
            subscription = stripe.Subscription.create(customer=stripe_customer.id,items=[{'plan':plan}])

        ## now stript work is finished
        ## now save the customer in your server
        customer = Customer()
        customer.user = request.user
        customer.stripeid = stripe_customer.id
        customer.membership = True
        customer.cancel_at_period_end = False
        customer.stripe_subscription_id = subscription.id
        customer.save()
        return redirect('home')
    
    else:
        ### when the page load

        ## this is the monthly config
        coupon = 'none'
        plan = 'monthly'
        price = 1000
        og_doller = 10
        coupon_doller = 0
        final_doller = 10
        if request.method == "GET" and 'plan' in request.GET:
            if request.GET['plan'] == 'yearly':

                ## this is the yearly config
                plan = 'yearly'
                price = 10000
                og_doller = 100
                final_doller = 100
        
        ## so monthly and yearly is done
        ## now check if there are any coupon
        ## this apply for monthly and yearly
        ### when the user press the redeem button 
        ### this form is not post it is get
        ### and it will add the coupn in the query string
        if request.method == 'GET' and 'coupon' in request.GET:
            print(coupons)
            co = request.GET['coupon'].lower()
            if co  in coupons:
                percentage = coupons[co]

                coupon_price = int((percentage/100)*price)
                price = price - coupon_price
                coupon_doller = str(coupon_price)[:-2] + '.' + str(coupon_price)[-2:]
                final_doller = str(price)[:-2] + '.' + str(price)[-2:]

        
        return render(request,'plans/checkout.html',{'plan':plan,'coupon':coupon,'price':price,'og_doller':og_doller,'coupon_doller':coupon_doller,'final_doller':final_doller})




def settings(request):
    membership = False
    cancel_at_period_end = False
    if request.method == 'POST':
        subscription = stripe.Subscription.retrieve(request.user.customer.stripe_subscription_id)
        subscription.cancel_at_period_end = True
        request.user.customer.cancel_at_period_end = True
        cancel_at_period_end = True
        subscription.save()
        request.user.customer.save()
    else:

        ## when the page load
        try:
            if request.user.customer.membership:
                membership = True
            if request.user.customer.cancel_at_period_end:
                cancel_at_period_end = True
        except Customer.DoesNotExist:
            membership = False
    return render(request, 'registration/settings.html', {'membership':membership,
    'cancel_at_period_end':cancel_at_period_end})


### sometiems super user 
### need to sync and check if the web service
### is in sync with the stript databse
### like if any administrator manually update the stripe
### database for any reason an make anyonce active or deactive
### again make sure this reflected here
### this function is called updateaccount
### and inly superuser can access it
### so we pass a lambda decorator


## like the lin1 function in c#
@user_passes_test(lambda u: u.is_superuser)
def updateaccounts(request):
    ## take all the customer from your database
    customers = Customer.objects.all()
    for customer in customers:
        ## get the updated subscription
        subscription = stripe.Subscription.retrieve(customer.stripe_subscription_id)

        ## now update your database based on the subscription
        if subscription.status != 'active':
            ## then deactivate them here
            customer.membership = False
        else:
            ## otherwise
            customer.membership = True
        ## again set their new period time
        
        customer.cancel_at_period_end = subscription.cancel_at_period_end

        ## then save 
        customer.save()
    
    return HttpResponse('<center><h1> Update Completed</h1><center>')